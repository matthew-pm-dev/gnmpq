#! usr/local/bin/ruby
## gnmp_logins.rb
##
## App that tests a list of known credentials against multiple device IP addresses
## Outputs successful logins to a text file formatted for use with gnmpq.rb
## Takes encrypted passwords generated by SIM-CRY.exe
## Masterkey for decryption must be provided at runtime
##
## Tests SSH and Telnet
## Author: Matthew Malyk

require 'net/ssh'
require 'net/telnet'
require 'netaddr'
require 'nmap/program'
require 'nmap/xml'
require 'io/console'

##
##
## Attempt to initiate SSH or telnet connection to specified IP address
## Return device status based on exception raised
##
##
def try_login(addr, login={}, flag)

	if flag == 'ssh'
		Net::SSH.start(addr, login[:user], :password => login[:pw], :timeout => 10, :number_of_password_prompts => 0)
	elsif flag == 'telnet'
		s = Net::Telnet::new("Host" => addr, "Timeout" => 20, "Prompt" => /.*[#>?]$/)
		s.waitfor(/name/)
		s.cmd('String' => login[:user], 'Match' => /[Pp]ass/)
		s.cmd(login[:pw]) { |c| return if c.include?("%") }
	end

rescue Net::SSH::AuthenticationFailed; return nil
rescue Errno::ETIMEDOUT, Timeout::Error; return "Failed: Timeout"
rescue Errno::ECONNREFUSED; return "Failed: Connection Refused"
rescue Errno::EHOSTUNREACH; return "Failed: Host Unreachable"
rescue; return "Failed: Unknown Error"
else return "Success! " + login[:name]
end

##
##

def decrypt(pw,key)
	begin
		s="";(3..6).each{|i|s<<i.chr};val=1;key.chars.each{|e|val=(val+e.ord)/2}
		return pw.gsub('"','').split(/[#{s}]/).collect{|b|b.chars}.collect{|c|((c.map(&:ord).map(&:to_s).map{|e|e.rjust(2,'0')}.collect{|n|n[0]}.join.to_i)-val).chr}.join
	rescue RangeError; return nil
	end
end

##
## END METHOD DEFINITIONS
##

F_IN_LOGIN = 'config/gnmp_helper.ini'
F_IN_IP = 'config/gnmp_find_login.ini'
F_OUT = 'info/gnmp_logins.txt'
F_NMAP_XML = 'info/scan.xml'
F_NMAP_OUT = 'info/gnmp_nmap_log.txt'

## create directories for output file if necessary
path = F_OUT.split('/')[0...-1].reject { |e| e.empty? }.join("\\")
system 'mkdir', path unless File.exists?(path) || path == ""

## KEXINIT Packet Length Fix
Net::SSH::Transport::Algorithms::ALGORITHMS[:encryption] = %w(aes128-cbc 3des-cbc blowfish-cbc cast128-cbc
aes192-cbc aes256-cbc none arcfour128 arcfour256 arcfour
aes128-ctr aes192-ctr aes256-ctr cast128-ctr blowfish-ctr 3des-ctr)

## preamble
puts "\n\nGNMP Find Login utility - tests logins against multiple IP addresses"
puts "Requires NMAP 5.0 or newer installed on your machine"
puts "  IP list at #{F_IN_IP}"
puts "  Encrypted password list at #{F_IN_LOGIN}"
puts "Results will be output to #{F_OUT}"

##
##
## pull login credentials from file specified: F_IN_LOGIN
##
## logins = hash of all logins {:user => username, 
##															:pw => decrypted password 
##  														:name => credential reference name }
##
## also decrypts master key and tests user input key for match
## program exits if key <=> masterkey mismatch
##
## 
print "\nEnter decryption key: "; key = STDIN.noecho(&:gets).chomp; puts

logins = []; mkey = nil
File.foreach(F_IN_LOGIN) do |l|
	next if l[0] == '#'
	if l.include?('MASTERKEY : ')
		mkey = decrypt(l.chomp.split(' : ').last,key)
	elsif l.include?(' // ')
		ls = l.chomp.split(" // ")
		logins << { :user => ls[0], :pw => ls[1], :name => ls[2] }
		logins.last[:pw] = decrypt(logins.last[:pw],key)
		logins.delete(logins.last) if logins.last[:pw] == nil
	end
end

unless mkey == key
	puts "\nInvalid decryption key!"
	sleep(2)
	exit
end

##
##
## pull list of all IP addresses to test from file specified: F_IN_IP
##
## addr[] = list of addresses
## 
## will parse /subnets using gem netaddr
##
##
addrs = []
File.foreach(F_IN_IP) do |line| 
	next if line[0] == '#'
	if /^\d+\.\d+\.\d+\.\d+\/\d+/.match(line) then addrs << NetAddr::CIDR.create(line.chomp).enumerate 
	elsif /^\d+\.\d+\.\d+\.\d+/.match(line)	then addrs << line.chomp
	end
end
addrs.flatten!

##
##
## finds local install of NMAP and uses scans input addresses to find any device with 
## open ports 22 or 23.  Builds a hash table of the results
##
## device_status[ip address] = { :con_type => ssh / telnet / nil
##  														 :message => text string describing device status }
##
## uses gem ruby-nmap
##
device_status = {}
addrs.each { |addr| device_status[addr] = { :con_type => nil, :message => "Failed: No Response"} }

Nmap::Program.scan( :targets => addrs, :ports => [22,23], :xml => F_NMAP_XML, :save => F_NMAP_OUT)
Nmap::XML.new(F_NMAP_XML) do |xml|
	xml.each_host do |host|
		host.each_port do |port|
			if port.state == :open
				device_status[host.ip] = { :con_type => port.service.name, :message => "Responded" }
				break
			elsif port.state == :closed || port.state == :filtered
				device_status[host.ip][:message] = "Failed: Connection Refused"
			end
		end
	end
end

##
##
## test all credentials against each device that responded on port 22 or 23
## 
## credentials are executed in order of entry, testing stops immediately when
## a successful login is found
##
## result is stored in device_status[:message]
##
##
device_status.each do |addr, info|

	next if info[:con_type] == nil

	print "\nTrying #{addr} via #{info[:con_type]}..."

	logins.each do |login|
		info[:message] = try_login(addr, login, info[:con_type])
		break if info[:message]
	end

	info[:message] = "Connection established but all supplied credentials failed" unless info[:message]

	if info[:message].include?('Success!')
		print "Success!"
		info[:message].prepend(" // #{info[:con_type]} // ")
	else print info[:message]
	end

end

##
##
## format results and output to text file specified F_OUT
##
##
su = "-- Successful Logins --\n\n"
fa = "\n-- Failed Logins --\n\n"
sc = device_status.select { |k,info| info[:message].include?('Success!') }.length

device_status.each do |addr,info|
	if info[:message].include?('Success!')
		su << "#{addr}#{info[:message].gsub('Success! ','')}\n"
	else
		fa << "#{addr} #{info[:message]}\n"
	end
end

puts "\n\nProcessing complete"
puts "Successfully logged into #{sc} / #{device_status.length} device(s)"
puts "Results written to #{F_OUT}"

File.write(F_OUT,su+fa)

puts
system("pause")
exit
