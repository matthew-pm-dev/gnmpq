#! usr/local/bin/ruby
## gnmpq.rb
##
## App that automates datamining devices for Global Network Mapping Project
## Attepts to connect to device and execute a specified list of show commands
## Logs output to text individual text file for each device
##
## Author: Matthew Malyk

require 'net/ssh/telnet'
require 'net/ssh'
require 'net/telnet'
require 'io/console'

##
##
## add screen method to string to filter unwanted output
##
##
class String
	def screen
		query = self.split("\n").first
		if self.include?('% Invalid input detected') && $filters.include?('invalid input')
			return "INVALID INPUT: #{query}" 
		elsif self.include?('Mac Address') && $filters.include?('empty MAC tables')
			return "TABLE EMPTY: #{query}" unless (/.{4}\..{4}\..{4}/).match(self)
		else return self
		end
		return self
	end
	def screen!; self.replace(screen); end
end

##
## END CLASS DEFINITIONS AND MODIFICATIONS
##

##
##
## request interface, vlan, or mac addresses from user for specific command
##
## return: hash { key:command => value:interfaces/vlans/macs }
##
##
def get_ivm(queries)

	ivm = {}

	queries.each do |q|
		if (/<.*>/).match(q)
			puts "\nSpecify values for \"#{q}\""
			if q.include?('<int>')
				puts "Valid input: all | 0 2 10 12-24" 
				print "Interfaces [all]: "
			elsif q.include?('<vlan>')
				puts "Valid input: active | assigned | 10 20 30-50 60"
				print "Vlans [active]: "
			elsif q.include?('<mac>')
				puts "Valid input: 1234:ABCD 5678:EFGH"
				print "Mac addresses: "
			end
			ivm[q] = gets.chomp.split
			ivm[q] = 'all' unless ivm[q].length > 0
		end
	end

	## expand range input
	ivm.each do |k,v|
		next if ['all', 'active', 'assigned'].any? { |e| v.include? e }
		range = v.select { |e| e.include?('-') }
		v.reject! { |e| e.include?('-') }
		range.each { |r| v << (r.split('-').first..r.split('-').last).to_a }
		ivm[k] = v.flatten.sort_by(&:to_i)
	end

	return ivm

end

##
##
## execute a command 
##
## return output from device following command and until next prompt as String
##
##
def exec_query(session, query)
	output = ""
	puts "     #{query}"
	session.cmd(query) { |c| output << c}
	output.screen!
	output << "\n\n\n"
	return output
end
	
##
##
## build a list of commands to execute by replacing placeholder ( <int>, <vlan>, <mac> )
## with supplied or collected values
##
## call exec_query with each command in the list
##
## return: full output of each command as String
##
##
def process_ivm(session, query, iv_list, ivm_values)

	output = ""

	if query.include?('<int>')

		list = iv_list[:int].chomp.split("\n").select { |e| e.include?('/') }
		list.select! { |e| ivm_values[query].include? e.split('/').last } unless ivm_values[query].include?('all')
		list.collect! { |e|  e.split.last }

	elsif query.include?('<vlan>')

		if ['all', 'assigned', 'active'].any? { |e| ivm_values[query].include? e }
			list = iv_list[:vlan].chomp.split("\n").select { |e| e.include?('active') }
			list.select! { |e| e.include?('/') } if ivm_values[query].include?('assigned')
			list.collect! { |e| e.split.first }
		else list = ivm_values[query]
		end

	elsif query.include?('<mac>')
		list = ivm_values[query]
	end

	## execute all commands
	list.each do |l|
		query_sub = query.gsub(/<.*>/, l)
		output << exec_query(session, query_sub)
	end

	return output

end

##
##
## attempt to initiate SSH or Telnet connection
##
## return:
## => success: telnet connection object
## => failure: error message as String
##
##
def try_login(addr, login, flag, log)

	if flag == 'ssh'
		ssh = Net::SSH.start(addr, login[:user], :password => login[:pw], :timeout => 10, :number_of_password_prompts => 0)
		tn = Net::SSH::Telnet.new("Session" => ssh, "Timeout" => 20, "Output_log" => log, "Prompt" => /.*[#>?]\s{0,1}$/)
	elsif flag == 'telnet'
		tn = Net::Telnet::new("Host" => addr, "Timeout" => 20, "Output_log" => log, "Prompt" => /.*[#>?]\s{0,1}$/)
		tn.waitfor(/name/)
		tn.cmd('String' => login[:user], 'Match' => /[Pp]ass/)
		tn.cmd(login[:pw]) { |c| return "Authentication Failed" if c.include?("%") }
	else return "Unrecognized connection type: #{flag}"
	end

rescue Net::SSH::AuthenticationFailed; return "Authentication Failed"
rescue Errno::ETIMEDOUT, Timeout::Error; return "Timeout"
rescue Errno::ECONNREFUSED; return "Connection Refused"
rescue Errno::EHOSTUNREACH; return "Host Unreachable"
rescue; return "Unknown Error"
else; return tn
end

##
##
## decrypt password strings generated by sim-cry
##
## return:
## => success: password as String
## => failure: nil
##
##
def decrypt(pw,key)
	begin
		s="";(3..6).each{|i|s<<i.chr};val=1;key.chars.each{|e|val=(val+e.ord)/2}
		return pw.gsub('"','').split(/[#{s}]/).collect{|b|b.chars}.collect{|c|((c.map(&:ord).map(&:to_s).map{|e|e.rjust(2,'0')}.collect{|n|n[0]}.join.to_i)-val).chr}.join
	rescue RangeError; return nil
	end
end

##
## END OF METHOD DEFINITIONS
##

F_HELPER = 'config/gnmp_helper.ini'
f_out = 'logs/gnmp_<address>.txt'
f_dump = 'logs/dump/gnmp_dump_<address>.txt'
logins = [] 	## valid credentials
devices = [] 	## list of devices to query and their credentials
queries = [] 	## commands to be executed
$filters = [] ## output filters

## preamble
puts "\nGNMP Query Utility - Executes show commands on multiple devices"
puts "Logs output #{f_out}"
puts "  Configuration at #{F_HELPER}"

## create directories for output file if necessary
path = f_dump.split('/')[0...-1].reject { |e| e.empty? }.join("\\")
system 'mkdir', path unless File.exists?(path) || path == ""

## KEXINIT Packet Length Fix
Net::SSH::Transport::Algorithms::ALGORITHMS[:encryption] = %w(aes128-cbc 3des-cbc blowfish-cbc cast128-cbc
aes192-cbc aes256-cbc none arcfour128 arcfour256 arcfour
aes128-ctr aes192-ctr aes256-ctr cast128-ctr blowfish-ctr 3des-ctr)

##
##
## get master key, credentials, and query commands from gnmp_helper.ini
##
## request key from user and compare against master key
## decrypt passwords if they match
##
##
print "\nEnter decryption key: "; key = STDIN.noecho(&:gets).chomp; puts

mkey = nil
File.foreach(F_HELPER) do |l|
	next if '#- '.chars.any? { |c| l[0] == c }
	if l.include?('MASTERKEY : ')
		mkey = decrypt(l.chomp.split(' : ').last,key)
	elsif l.include?(' // ')
		ls = l.chomp.split(' // ')
		next unless ls.length == 3
		logins << { :user => ls[0], :pw => ls[1], :name => ls[2] }
		logins.last[:pw] = decrypt(logins.last[:pw],key)
		logins.delete(logins.last) if logins.last[:pw] == nil
	elsif /^filter\s/.match(l)
		$filters << l.chomp.gsub('filter ','')
	elsif l.include?(':yes')
		queries << l.split(':').first
	end
end

print $filters

unless mkey == key
	puts "\nInvalid decryption key!"
	sleep(2)
	exit
end

## request interface, vlan, and MAC values from user if necessary
ivm_values = get_ivm(queries)

##
##
## request source file for device/login information
##
## grab list of device IP addresses and associated logins information from file
## default file: gnmp_logins.txt - this file is generated by gnmp_find_logins.rb
##
##
print "\nIP address Source file [info/gnmp_logins.txt]: "; f_source = gets.chomp
f_source = 'info/gnmp_logins.txt' unless f_source.length > 0

File.foreach(f_source) do |l|
	break if l.include?('-- Failed Logins --')
	if l.include?(' // ')
		ls = l.chomp.split(' // ')
		devices << { :ip => ls[0], :con_type => ls[1], :login => ls[2] }
	end
end

##
##
## login to each device with supplied credentials and execute all specified commands
##
## automatically terminates session if prompted for emable password and outputs "Authentication Failed"
##
## formatted results logged to f_out_sub
## raw data from device logged to f_dump_sub
##
##
devices.each do |device|

	tn = nil; login = nil; output = ''

	## grab correct credentials and prepare output files
	logins.each { |l| login = l if device[:login] == l[:name] }
	f_out_sub = f_out.gsub("<address>", device[:ip])
	f_dump_sub = f_dump.gsub("<address>", device[:ip])
	File.write(f_out_sub,'')
	File.write(f_dump_sub,'')

	print "\nTrying #{device[:ip]}... "

	begin

		tn = try_login(device[:ip], login, device[:con_type], f_dump_sub)

		if tn.is_a?(String)
			puts tn
			next
		else

			puts "Success!"										
			puts "   Processing Commands..."

			tn.cmd('enable') { |c| 4.times { tn.puts('quit') } if /[Pp]assword/.match(c) }

			tn.cmd('terminal length 0')

			## grab full list of interfaces and vlans if required for a requested command
			iv_list = { :int => "", :vlan => "" }
			tn.cmd('show run | i interface') { |c| iv_list[:int] << c } if queries.select { |e| e.include?('<int>') }.length > 0
			tn.cmd('show vlan') { |c| iv_list[:vlan] << c } if queries.select { |e| e.include?('<vlan>') }.length > 0

			queries.each do |q|
				if (/<.*>/).match(q)
					output << process_ivm(tn, q, iv_list, ivm_values)
				else
					output << exec_query(tn, q)
				end
			end

			File.write(f_out_sub,output)
			puts "   Output logged to #{f_out_sub}"

			tn.cmd('terminal length 25')
			tn.close

		end
	rescue Net::SSH::Disconnect; puts "  Disconnected"; next
	rescue Errno::ETIMEDOUT; "  Timeout"; next
	end

end

puts "Processing Complete!"
puts
system("pause")
exit
